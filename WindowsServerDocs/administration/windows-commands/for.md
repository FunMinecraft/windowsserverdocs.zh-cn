---
title: 有关
description: 'Windows 命令主题 * * *- '
ms.custom: na
ms.prod: windows-server-threshold
ms.reviewer: na
ms.suite: na
ms.technology: manage-windows-commands
ms.tgt_pltfrm: na
ms.topic: article
ms.assetid: e275726c-035f-4a74-8062-013c37f5ded1
author: coreyp-at-msft
ms.author: coreyp
manager: dongill
ms.date: 10/16/2017
ms.openlocfilehash: 13a44bc3497b44d60bd4d351e389d493a50f1269
ms.sourcegitcommit: 0d0b32c8986ba7db9536e0b8648d4ddf9b03e452
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/17/2019
ms.locfileid: "59869458"
---
# <a name="for"></a>有关



在每个文件指定的命令运行一组文件中。

有关如何使用此命令的示例，请参阅[示例](#BKMK_examples)。

## <a name="syntax"></a>语法

```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```

## <a name="parameters"></a>Parameters

|参数|描述|
|---------|-----------|
|{%%\|%}\<变量 >|必需。 表示可替换参数。 使用一个百分号 (**%**) 来执行**为**命令在命令提示符处。 使用双百分号 (**%%**) 来执行**为**命令批处理文件中。 变量是区分大小写，它们必须如表示的字母数字值与 **%A**， **%B**，或 **%C**。|
|(\<设置 >)|必需。 指定一个或多个文件、 目录或文本字符串或在其上运行该命令的值的范围。 两边需要圆括号。|
|\<命令 >|必需。 指定要在每个文件、 目录或文本字符串或上中包含的值的范围缩小执行的命令*设置*。|
|\<CommandLineOptions>|指定你想要指定命令中使用任何命令行选项。|
|/?|在命令提示符下显示帮助。|

## <a name="remarks"></a>备注

-   使用**为**

    可以使用**为**命令在批处理文件或直接从命令提示符。
-   使用 batch 的参数

    以下属性应用于**为**命令：  
    -   **有关**命令替换 **%* * * 变量*或 **%%* * * 变量*与之前指定的命令处理的所有文件在指定集中每个文本字符串。
    -   变量名称是区分大小写、 全局和没有更多比 52 可以处于活动状态一次。
    -   若要避免与批参数相混淆 **%0**通过 **%9**，可以使用任何字符*变量*除外数字 0 到 9。 简单的批处理文件，单个字符如 **%%** 起作用。
    -   可以使用的多个值*变量*复杂的批处理文件来区分不同的可替换变量中。
-   指定文件的组

    *设置*参数可以代表文件的单个组或多个文件组。 可以使用通配符 (**&#42;** 并 **？**) 指定的文件设置。 以下是有效的文件集：  
    ```
    (*.doc) 
    (*.doc *.txt *.me)
    (jan*.doc jan*.rpt feb*.doc feb*.rpt)
    (ar??1991.* ap??1991.*)
    ```  
    当你使用**有关**命令中的第一个值*设置*替换 **%* * * 变量*或 **%%* * * 变量*，并指定命令处理此值。 这将继续，直到与相对应的所有文件 （或文件组）*设置*值进行处理。
-   使用**中**并**执行**关键字

    **中**并**不要**不是参数，但必须将它们用于**为**。 如果省略了其中任何一个关键字，将显示一条错误消息。
-   使用其他形式的**为**

    如果 （这是默认值），启用了命令扩展的以下附加的窗体**为**支持：  
    -   仅为目录

        如果*设置*包含通配符字符 (**&#42;** 或 **？**)，指定*命令*执行每个目录 （而不是一组指定目录中的文件） 的匹配*设置*。

        语法为：  
        ```
        for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>] 
        ```  
    -   Recursive

        将沿着目录树的根节点的*驱动器*:*路径*，并执行**为**树的每个目录中的语句。 如果后不指定任何目录 **/r**，作为根目录使用当前目录。 如果*设置*只是一个句点 （.），则将只枚举目录树。

        语法为：  
        ```
        for /r [[<Drive>:]<Path>] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
        ```  
    -   循环访问一系列值

        使用迭代变量设置的起始值 (*启动*#)，然后单步执行一组范围的值，直到值超过设置的终止值 (*最终*#)。 **/l**通过比较中将执行迭代*启动*# 新*最终*#。 如果*启动*# 是小于*最终*# 将执行该命令。 当迭代变量超出*最终*#，命令行界面退出循环。 你还可以使用负*步骤*# 若要逐步执行中递减的值的范围。 例如，(1,1,5) 生成序列 1 2 3 4 5 和 (5，-1，1) 生成序列 5 4 3 2 1。

        语法为：  
        ```
        for /l {%%|%}<Variable> in (<Start#>,<Step#>,<End#>) do <Command> [<CommandLineOptions>]
        ```  
    -   循环访问和文件分析

        使用文件解析为进程命令输出、 字符串和文件内容。  使用迭代变量来定义的内容或你想要检查，字符串和使用的各种*ParsingKeywords*选项，若要进一步修改的分析。  使用*ParsingKeywords*令牌选项以指定应作为迭代变量传递的令牌类型。 请注意，当使用不带令牌选项， **/f**只能检查的第一个标记。

        文件解析过程包括读取输出、 字符串或文件的内容，然后将其分解成独立的文本行并将每行解析为零个或多个标记。 **为**迭代变量值设置为令牌，然后调用循环。 默认情况下 **/f**传递第一个空白分隔标记每个文件的每一行。 空白行将跳过。

        语法是：  
        ```
        for /f ["<ParsingKeywords>"] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
        for /f ["<ParsingKeywords>"] {%%|%}<Variable> in ("<LiteralString>") do <Command> [<CommandLineOptions>]
        for /f ["<ParsingKeywords>"] {%%|%}<Variable> in ('<Command>') do <Command> [<CommandLineOptions>]
        ```  
        *设置*参数指定一个或多个文件的名称。 打开、 读取和处理移到下一个文件中的每个文件*设置*。 若要覆盖默认的分析行为，请指定*ParsingKeywords*。 这是带引号的字符串，它包含一个或多个关键字，若要指定不同的分析选项。

        如果您使用**usebackq**选项，请使用以下语法之一：  
        ```
        for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in ("<Set>") do <Command> [<CommandLineOptions>]
        for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in ('<LiteralString>') do <Command> [<CommandLineOptions>]
        for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in (`<Command>`) do <Command> [<CommandLineOptions>]
        ```  
        下表列出了可用于分析关键字*ParsingKeywords*。  
        |关键字|描述|
        |-------|-----------|
        |eol=\<c>|指定行尾字符 （只是一个字符）。|
        |skip=\<N>|指定要跳过文件开头的行数。|
        |delims=\<xxx>|指定的分隔符集。 这会替换默认的分隔符集的空格和制表符。|
        |tokens=\<X,Y,M–N>|指定从每个行的令牌将传递给**为**每次迭代的循环。 因此，分配其他变量的名称。 *M*–*N*指定一个范围，从*M*通过第*N*个令牌。 如果中的最后一个字符**令牌 =** 字符串是一个星号 (**&#42;**)、 分配一个附加的变量，和它在被分析的最后一个标记之后会接收在行上的剩余文本。|
        |usebackq|指定到： 执行后带引号的字符串作为命令、 使用单引号字符串作为文本字符串，或对于包含空格的长时间文件的名称，允许在文件名*\<设置\>* 到每个括起来双重引号。|
    -   变量替换

        下表列出了可选的语法 (对于任何变量**我**)。  
        |变量使用修饰符|描述|
        |----------------------|-----------|
        |%~I|展开 **%I**后者中删除任何周围的引号 ("")。|
        |%~fI|展开 **%I**为完全限定的路径名称。|
        |%~dI|展开 **%I**到驱动器号。|
        |%~pI|展开 **%I**仅的路径。|
        |%~nI|展开 **%I**为文件名称。|
        |%~xI|展开 **%I**向文件名称扩展仅。|
        |%~sI|扩展路径以只包含短名称。|
        |%~aI|展开 **%I**对文件的文件属性。|
        |%~tI|展开 **%I**到的日期和时间的文件。|
        |%~zI|展开 **%I**到文件的大小。|
        |%~$PATH:I|搜索路径环境变量中列出的目录，并展开 **%I**到找到的第一个目录的完全限定名称。 如果未定义环境变量名称，或通过搜索找不到该文件，此修饰符将扩展为空字符串。|

        下表列出了可用于获取复合结果的修饰符组合。  
        |使用组合修饰符的变量|描述|
        |--------------------------------|-----------|
        |%~dpI|展开 **%I**到驱动器号和路径仅。|
        |%~nxI|展开 **%I**文件的名称和仅扩展到。|
        |%~fsI|展开 **%I**到使用仅短名称的完整路径名称。|
        |%~dp$PATH:I|在搜索中的 PATH 环境变量列出目录 **%I**并扩展到驱动器号和找到的第一个路径。|
        |%~ftzaI|展开 **%I**于输出行，就像**dir**。|

        在上述示例中，您可以替换为 **%I**和使用其他有效的值的路径。 一个有效**有关**变量名称终止**%~** 语法。

        使用大写的变量名称类似于 **%I**，可以使代码更具可读性，并避免混淆和修饰符，不区分大小写的。
-   分析字符串

    可以使用**为 /f**分析即时字符串上的逻辑通过包装*\<LiteralString\>* 中任何一种： 双引号 (*而无需*"usebackq") 或在单引号 (*与*"usebackq")-例如，("MyString") 或 (MyString)。 *\<LiteralString\>* 被视为输入文件中的单个行。 分析时*\<LiteralString\>* 双引号，在命令符号 (如 **\\ \& \| \> \< \^**) 视为普通字符。
-   分析输出

    可以使用**为 /f**命令来分析命令的输出将置于后引号*\<命令\>* 的括号之间。 它被视为传递给子 Cmd.exe 命令行。 将输出到内存中捕获并分析像它是一个文件。

## <a name="BKMK_examples"></a>示例

若要使用**为**在批处理文件中，使用以下语法：
```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```
若要通过使用可替换变量具有扩展名为.doc 或.txt 的当前目录中显示的所有文件的内容 **%f**，类型：
```
for %f in (*.doc *.txt) do type %f 
```
在前面的示例中，在当前目录中具有扩展名为.doc 或.txt 每个文件替换为 **%f**变量之前显示的每个文件的内容。 若要使用此命令的批处理文件中，将为每个匹配项 **%f**与 **%%**。 否则为将忽略变量，并显示一条错误消息。

若要分析文件，同时忽略注释行，请键入：
```
for /f "eol=; tokens=2,3* delims=," %i in (myfile.txt) do @echo %i %j %k
```
此命令分析 Myfile.txt 中的每一行。 它将忽略以分号开头的行，并传递到每一行的第二个和第三个令牌**为**正文 （由逗号或空格分隔的令牌）。 正文**有关**语句引用 **%i**来获取第二个令牌， **%j**获取第三个令牌，和 **%k**若要获取所有剩余的令牌。 如果你提供的文件名中包含空格，则使用引号将文本 （例如，"文件名称"）。 若要使用引号，必须使用**usebackq**。 否则，双引号被解释为定义要分析的文本字符串。

**%i**中显示声明**为**语句。 **%j**并 **%k**隐式声明使用**令牌 =**。 可以使用**令牌 =** 指定最多 26 个令牌，前提是它不会导致尝试声明一个变量高于字母"z"或"Z。

下面的示例枚举当前环境中的环境变量名称。 来分析命令的输出将置于*设置*在括号中，键入：
```
for /f "usebackq delims==" %i in ('set') do @echo %i 
```

#### <a name="additional-references"></a>其他参考

[命令行语法解答](command-line-syntax-key.md)
